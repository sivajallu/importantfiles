                                                                git diff command
                                                                ================

git diff index.html 

Req1 : To see the difference in file content between working directory and staging area
========================================================================================

diff --git a/index.txt b/index.txt
index fcb5845..b5bf6bc 100644
--- a/index.txt
+++ b/index.txt
@@ -1 +1,2 @@
 animals
+birds


diff --git a/index.txt b/index.txt
==================================
syntax which is generated by the git 

a/index.txt --> represents source (staging area) 
b/index.txt --> represents destination (working directory)


fcb5845 --> hash of the file content from source / staging
b5bf6bc --> hash of the file content from destination / workspace

100644 --> git file mode
git file mode contains two parts

the first 3 digits represents type of the file(.txt)
next 3 digits represents file premissions.

git always follows linux commands.

100 --> represents type of the file
644 --> file premissions rw(file owner)-r(group owners)-r(other users) 
--rw-r-r 
   for file owner read and write premissions
   group and other users we have read premissions
        4 - r
        2 - w
        1 - x

there are 3 types of users in linux

group,owners and users


--- a/index.txt : source file is missing some lines(staging area)
+++ b/index.txt : new lines added in the destination file (working directory)


@@ -1 +1,2 @@
==============
-1 :
in the soruce one line is missing(staging area)

+1,2 :
in the destination we have one line and second line



 animals
+birds
========================================================================

if anyline is prefixed with space means it is unchanged

if anyline is prefixed with + means it is added in destination copy.

if anyline is prefixed with - means it is removed from destination copy.


Req2 : To see the difference in file content between working directory and last commit(local repository)
========================================================================================================

last commit refers using HEAD
HEAD represents the last commit. 

git diff HEAD index.txt

Req3 : To see the difference in file content between staging directory and last commit(local repository)
========================================================================================================
staged : represents the file in the staging area

git diff --staged HEAD index.txt


Req4 : To see the difference in file content between working directory and specific commit(local repository)
========================================================================================================

git log --oneline

f804c64 (HEAD -> master) second commit and file contains 4 lines
d838e61 first commit file contains 1 line

git diff d838e61 index.txt

Req5 : To see the difference in file content between staging area and specific commit(local repository)
========================================================================================================

git diff --staged d838e61

Req6 : To see the difference in file content between two specified commits (local repository)
========================================================================================================
git diff f804c64 d838e61

git diff  d838e61 f804c64

Req7 : To see the difference in file content between two branches
========================================================================================================

git diff branch1 branch2


Req8 : To see the difference in file content between local and remote repository
========================================================================================================

git diff branch1(local repository) origin/branch2(remote repository)

origin is actully url of the remote repository





                                                      git rm command
                                                      ==============


to list all the file in working directory
=========================================
$ls


to list all the files in staging area
=====================================
$git ls-files


Req1 : remove file from both working directory and staging area
================================================================

git rm file1.txt

this command will remove the files from both working directory and staging area

Req2 : remove all the files from both working directory and staging area
=========================================================================

git rm -r .

Req3 : remove files from staging area
=====================================

git rm --cached file2.txt


Req4 : remove files from working directory
==========================================

rm file3.txt



                                                        GIT checkout command
                                                        ====================
we can use checkout command to discard unstaged changes in the tracked files of working directory.


tracked files :
files which are present in the working directory which are already moved to staging or repository once.

untracked files :
files which are present in the working directory which are not moved to staging and repository.

unstaged changes :
changes are not part of the staging area.

unstaged changes in the tracked files:
files which are present in the working directory which are already moved to staging or repository once.
after moving the files to staging or repository we made some changes in the working directory
and those changes are not part of the staging area.

about this command:
===================

only for the working directory

to discard unstaged changes(the changes which are not added to staging area)

in the tracked file (the files which are already added to staging area / commit)

this command is used to undo the changes in the working directory

checkout command is not applicable for untracked files.

checkout command is applicable for tracked files.


git checkout -- file1.txt

it will discard unstaged changes in the tracked files.


                                                         git reset command
                                                         =================
1)to remove changes from staging area
2)to undo commits at repository level


1)to remove changes from staging area :
=======================================
it is exactly opposite of add command

git add index.txt

git reset index.txt

2)to undo commits at repository level
=====================================

in working directory and staging area level we talk about files

in repository level we talk about commits

Moves the HEAD to the specificed commit , and all remaining recent commits will be removed.

mode will decide whether these changes are going to remove from staging area and working directory or not.


syntax :

git reset <mode> <commit-id>


there are 3 types of modes

---mixed
--soft
--hard

commit-id 
7922ae6 (HEAD -> master) committed file3 : this is the latest commit,head and master is pointing to the latest commit.

e75d8af committed file2

58956fe commit file1

reset with --mixed mode:
========================
it is a default mode
to discard commits in the local repository and to discard changes in the staging area.
it will not touch working directory.

git reset --mixed e75d8af : it will discard latest commit changes from working directory and staging area.

git reset --mixed 58956fe : it will discard latest commit changes and last 2 commit changes 
from working directory and staging area.

commit-id 
910de92 (HEAD -> master) committed file3
e75d8af committed file2
58956fe commit file1


reset with --soft mode:
========================
it is exactly same as --mixed mode , but changes are available in working directory as well as staging area.
it will not touch working directory and staging area.
as changes are already present in the staging area,just we have to use commit to revert back.

git reset --soft e75d8af; it will discard 910de92 commit changes from working directory and staging area.

reset with --hard mode:
========================
it is exactly same as --mixed mode , but changes will be removed from every where (in working directory,staging area,local repository).
we cannot revert back our changes.
it is very dangerous.




                                                   GIT branching
                                                   =============

noramally when we create a project we will create serveral files and we will do serveral type of commits.
where exactly serveral files and commits will be placed ?
by default it will go to master branch

as soon as you create a local repository by default master branch will be created.
as soon as you do first commit master branch will be created.

what ever file you have created in the project and 
what ever files you have added to the staging all the files will be placed in the master branch itself.


and also commits will be done in the master branch itself.


so that is the reason master is the main branch.


in version control system master is the main branch.


all the source code(completed code or main code) will be placed in the master branch itself.


we can also create another branches in the git.

we can also place code and commits in the particular branches.


then why do we need another branches ?
=======================================

for parallel development.
we can keep all the code very clean.
no need to mess up the existing code in the master branch.



generally we create the branch from the master branch.

each developer will create a branch from the master and add files and do commits in that branch.

once we create branch(feature branch) from the main branch it will inherit all the files and commits from the master branch.

the main objective of creating new branch((feature branch)) from master branch is with out disturbing the main branch 
and to avoid conflict and to achive parallel development.

after files and commits are added to newly created branch(feature branch) we can push them to remote repository or we can merge them into main branch.


each branches are independent or isolated.

what ever files that you have added in the feature branch those files will not be available in the master branch.

i.e
what ever commits and files you have added in the child branch it will not impact the master branch.


what ever commits you do in the master branch those commits will not available in the feature branch.


what ever files and commits are present in the master branch while creating new branch(feature branch) at that time it will
inherit all the files and commits into feature branch.


every branch is isolated.
what changes you made in the one branch it will not be impacted in the other branch until and unless you merge the branch.

we can create n-number of branches.


there are set of commands in branching:
to create a branch
to view different branches available in the repository
how to add files to particular branch
how to switch from one branch to another branch.

create master branch in git :
=============================

to get the master branch atleast we need to have one file in the project 
and that file will be added to staging and should be committed.

then git will automatically create master branch.


different commands:
===================

to view different branches available in the repository :
========================================================

git branch
git status

*master (this is the master branch) * indicates active branch

master branch is the default branch.

active branch means we are currently working on the master branch.

to create new branch :
======================

git branch <branch-name>

git branch br1


whatever that we have in the master branch will be inherited to br1

because after commiting the changes in the master branch we have created br1 from the master branch.


how to switch from one branch to another branch
===============================================
we use git checkout command to switch another branch

there are two usecases :

git checkout:
we can use checkout command to discard unstaged changes in the tracked files of working directory.
(to discard unstaged changes in the working directory)

git checkout <branch-name>

git checkout br1

br1 is the active branch


creating and switching to another branch:
=========================================

git checkout -b <branch-name>



note : in master branch we always maintain the source code.

                                                         
                                                         git merging
                                                         ===========


after completing the development in the feature branch we will merge our changes to develop branch.

merging can happen in two different ways:
fast-forward merge
three-way merge

fast-forward merge:
===================

we make changes in the feature branch.

we don't make any changes in the master branch.

once development is done in the feature branch we will merge our changes to master branch.

whatever changes (files,commits) are there in the master branch while creating feature branch all the changes are inherited 
to feature branch.

once we create the feature branch from master branch we are not supposed to make any changes in the master branch.

changes happened in the feature branch only.

once we merge our changes to master branch HEAD will point to new commit.

there are less chances get conflicts between the code.

when ever we merge our changes to master branch no new commit will happen.

merge commit will not happen.

three-way merge :
=================
we can make changes in both master branch and feature branch as well.
there are more chances get conflicts between the code.
once we create the feature branch from master branch we can work in the master branch also.
whatever changes (files,commits) are there in the master branch while creating feature branch all the changes are inherited 
to feature branch.
once we merge our changes to master branch HEAD will point to new commit.
development happens in both master branch and feature branch.

when ever we merge our changes to master branch new commit will happen and this is called merge commit.

git will create a merge commit.

merge commit will happen.

HEAD ponter will move to merge commit.


how to execute merge command :
==============================
first you should switch to master branch and execute merge command.

git checkout master

git merge feature


f60049e (HEAD -> master, feature) C2F
d26e903 C1F
13a2eaa C2M
eb91c23 C1M

if we don't do any commits in the master branch git automatically create fast-forward merge.


'recursive' strategy' represents three way merge

549fb8f (HEAD -> master) Merge branch 'feature' :wq!:
e5feaa0 C3M
db62df5 (feature) C2F
030bf76 C1F
5b7c5ff C2M
c2e103e C1M


after merging we can delete the feature branch.





                                                         resolve merge conflicts
                                                         =======================
There are two types of merges
=============================
1.fast-forward merge
2.three-way merge

In three-way merge type, merge conflicts will occur.

if there are any conflicts merge will not happen.


Auto-merging test.txt
CONFLICT (content): Merge conflict in test.txt
Automatic merge failed; fix conflicts and then commit the result.

git log --oneline --graph

to delete the branch we use below command:
==========================================
git branch -d feature



                                                         git rebase
                                                         ==========
three-way merge :
==================
in three-way merge concept whenever we merge feature branch with master branch new merge commit will be created.
new merge commit will solve the conflicts.
it is completely non-linear commit.
for one commit there will be  mutiple parent commits.

fast-forward merge :
=====================
the fast-forward merge is completely linear 
for each commit there will be one parent commit.
even we merge the feature branch into master branch again there will be one parent commit for one feature  commit.


In three-way merge
==================
1)new merge commit will be created.
2)every commit is having more that one parent commit.
3)we should resolve the conflicts there.

to overcome these 3 we have a rebase command.


in rebase we follow only fast-forward merge 

to know how may commits we have done in the master branch:
git log --oneline master;

to know how may commits we have done in the feature branch:
git log --oneline feature;

padmaram@padmaram-laptop:~/gitproject$ git log --oneline master;
9971b26 (master) C3M
2b9599a C2M
cceea68 C1M


before applying rebase:
=======================

ec04dd2 (feature) C2F
1c8a417 C1F
2b9599a C2M
cceea68 C1M

padmaram@padmaram-laptop:~/gitproject$ git log --oneline feature;
cbe2cc9 (HEAD -> feature) C2F
4acabc0 C1F
9971b26 (master) C3M
2b9599a C2M
cceea68 C1M


after applying rebase:
======================
cbe2cc9 (HEAD -> feature) C2F
4acabc0 C1F
9971b26 (master) C3M
2b9599a C2M
cceea68 C1M

                                                   GIT HUB 
                                                   =======

remote repository url : https://github.com/sivajallu/testrepo.git
https://github.com/sivajallu/testrepo.git


git clone 'https://github.com/sivajallu/testrepo.git'


